<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Engine_UCICommandCancel" xml:space="preserve">
    <value>UCI command '{0}' canceled.</value>
  </data>
  <data name="Engine_ProcessStartFailed" xml:space="preserve">
    <value>Failed to start process.</value>
  </data>
  <data name="Engine_UnexpectedTryKill" xml:space="preserve">
    <value>Unexpected error while try killing process.</value>
  </data>
  <data name="Engine_DisposeFail" xml:space="preserve">
    <value>Dispose failed.</value>
  </data>
  <data name="Engine_UCICommand" xml:space="preserve">
    <value>Executing UCI command '{0}'.</value>
  </data>
  <data name="Engine_UCIStarted" xml:space="preserve">
    <value>UCI engine {0} by {1} started.</value>
  </data>
  <data name="Engine_UCIStopped" xml:space="preserve">
    <value>UCI engine {0} by {1} stopped.</value>
  </data>
  <data name="Board_InvalidMove_InvalidPosition" xml:space="preserve">
    <value>Invalid move: invalid algebraic position - {0}.</value>
  </data>
  <data name="Board_InvalidFEN_Empty" xml:space="preserve">
    <value>Invalid FEN: input is empty or null.</value>
  </data>
  <data name="Board_InvalidFEN_PartsCount" xml:space="preserve">
    <value>Invalid FEN: expected 6 space-separated fields (piece, active color, castling, en-passant, halfmove, fullmove).</value>
  </data>
  <data name="Board_InvalidFEN_RowsCount" xml:space="preserve">
    <value>Invalid FEN: expected 8 ranks in the piece-placement field.</value>
  </data>
  <data name="Board_InvalidFEN_InvalidPiece" xml:space="preserve">
    <value>Invalid FEN: invalid piece '{0}' at file {1} in rank {2}.</value>
  </data>
  <data name="Board_InvalidFEN_InvalidRowSquares" xml:space="preserve">
    <value>Invalid FEN: rank {0} contains {1} files (must be 8).</value>
  </data>
  <data name="Board_InvalidFEN_InvalidEP" xml:space="preserve">
    <value>Invalid FEN: invalid en-passant square - {0}.</value>
  </data>
  <data name="Board_InvalidFEN_RowOverflow" xml:space="preserve">
    <value>Invalid FEN: rank {0} contains too many files.</value>
  </data>
  <data name="Board_InvalidFEN_InvalidHalfMove" xml:space="preserve">
    <value>Invalid FEN: halfmove clock is not a valid integer - {0}.</value>
  </data>
  <data name="Board_InvalidFEN_InvalidFullMove" xml:space="preserve">
    <value>Invalid FEN: fullmove number is not a valid integer - {0}.</value>
  </data>
  <data name="Board_InvalidMove_SameSquare" xml:space="preserve">
    <value>Invalid move: same square.</value>
  </data>
  <data name="Board_InvalidMove_NullSquare" xml:space="preserve">
    <value>Invalid move: origin or target square (or both) is null or empty.</value>
  </data>
  <data name="Board_InvalidMove_EmptyPosition" xml:space="preserve">
    <value>Invalid move: empty origin - {0}.</value>
  </data>
  <data name="Board_InvalidMove_InvalidPiece" xml:space="preserve">
    <value>Invalid move: piece to move is the wrong color - {0}.</value>
  </data>
  <data name="Board_InvalidState_KingMissing" xml:space="preserve">
    <value>Invalid state: {0} king is missing from board.</value>
  </data>
  <data name="Board_InvalidMove_KingUnderAttack" xml:space="preserve">
    <value>Invalid move: move {0}-{1} exposes king to check.</value>
  </data>
  <data name="Board_InvalidMove_SameColor" xml:space="preserve">
    <value>Invalid move: origin and target are occupied by same color pieces.</value>
  </data>
  <data name="Board_InvalidState_UnknownPiece" xml:space="preserve">
    <value>Invalid state: piece is unknown.</value>
  </data>
  <data name="Board_InvalidMove" xml:space="preserve">
    <value>Invalid move: {0} {1}'s move not by rules.</value>
  </data>
  <data name="Board_Color_White" xml:space="preserve">
    <value>white</value>
  </data>
  <data name="Board_Color_Black" xml:space="preserve">
    <value>black</value>
  </data>
  <data name="Board_Pieces_Pawn" xml:space="preserve">
    <value>pawn</value>
  </data>
  <data name="Board_Pieces_Rook" xml:space="preserve">
    <value>rook</value>
  </data>
  <data name="Board_Pieces_Knight" xml:space="preserve">
    <value>knight</value>
  </data>
  <data name="Board_Pieces_Bishop" xml:space="preserve">
    <value>bishop</value>
  </data>
  <data name="Board_Pieces_Queen" xml:space="preserve">
    <value>queen</value>
  </data>
  <data name="Board_Pieces_King" xml:space="preserve">
    <value>king</value>
  </data>
  <data name="Board_InvalidMove_PromotionPiece" xml:space="preserve">
    <value>Invalid move: {0} is invalid for promotion.</value>
  </data>
  <data name="Engine_NoExecutable" xml:space="preserve">
    <value>Engine executable path is empty or file not found.</value>
  </data>
  <data name="Options_UnsupportedOptionType" xml:space="preserve">
    <value>Unsupported option type '{0}'.</value>
  </data>
  <data name="Options_MalformedType" xml:space="preserve">
    <value>Malformed type string: property without value.</value>
  </data>
  <data name="Options_UnknownProperty" xml:space="preserve">
    <value>Unknown property '{0}' in type string.</value>
  </data>
  <data name="Options_InvalidOptionType" xml:space="preserve">
    <value>Invalid option type '{0}' for enum mapping.</value>
  </data>
  <data name="Options_EmptyType" xml:space="preserve">
    <value>Option type is empty.</value>
  </data>
  <data name="Engine_UCICommandTimeout" xml:space="preserve">
    <value>UCI command '{0}' timed out.</value>
  </data>
  <data name="Engine_UCICommandFail" xml:space="preserve">
    <value>UCI command '{0}' failed.</value>
  </data>
  <data name="Options_EmptyName" xml:space="preserve">
    <value>Option name is empty</value>
  </data>
  <data name="Engine_OptionTypeMissmatch" xml:space="preserve">
    <value>Option '{0}' expected to be of type '{1}' but the actual type is '{2}'.</value>
  </data>
</root>